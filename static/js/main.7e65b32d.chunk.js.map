{"version":3,"sources":["components/cell/Cell.tsx","components/app/App.tsx","index.tsx"],"names":["Cell","type","children","className","getRandomInt","max","Math","floor","random","storedBestResult","localStorage","getItem","App","useState","tick","setTick","Number","bestScore","_setBestScore","snakeCells","setSnakeCells","direction","setDirection","snake","setSnake","foodCell","setFoodCell","gameOver","setGameOver","matrix","useEffect","setInterval","cur","document","onkeydown","e","key","length","split","curRow","curCol","nextRow","nextCol","nextHead","randomPosition","col","row","slice","val","newSnakeCells","forEach","node","setItem","String","i","j","push","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.7e65b32d.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./cell.css\";\r\n\r\nexport type CellType = \"snake\" | \"dead-snake\" | \"food\" | \"empty\";\r\nexport const Cell = ({\r\n  type,\r\n  children,\r\n}: {\r\n  type: CellType;\r\n  children?: any;\r\n}) => {\r\n  return <div className={`cell cell--${type}`}>{children} </div>;\r\n};\r\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { Cell, CellType } from \"../cell/Cell\";\nimport \"./app.css\";\n\nconst getRandomInt = (max: number) => {\n  return Math.floor(Math.random() * Math.floor(max));\n};\n\nconst storedBestResult = localStorage.getItem(\"best\");\nexport const App = () => {\n  const [tick, setTick] = useState(0);\n  const [bestScore, _setBestScore] = useState(Number(storedBestResult));\n\n  const setBestScore = (val: number) => {\n    localStorage.setItem(\"best\", String(val));\n    _setBestScore(val);\n  };\n  const [snakeCells, setSnakeCells] = useState<{ [key: string]: boolean }>({\n    \"0:0\": true,\n    \"0:1\": true,\n    \"0:2\": true,\n  });\n  const [direction, setDirection] = useState<\"up\" | \"right\" | \"down\" | \"left\">(\n    \"right\"\n  );\n  const [snake, setSnake] = useState([\"0:0\", \"0:1\", \"0:2\"]);\n  const [foodCell, setFoodCell] = useState(\"5:5\");\n  const [gameOver, setGameOver] = useState(false);\n  const rows = 10;\n  const columns = 10;\n  const matrix: any = [];\n\n  useEffect(() => {\n    setInterval(() => {\n      setTick((cur) => cur + 1);\n    }, 200);\n\n    document.onkeydown = (e: KeyboardEvent) => {\n      if (e.key === \"ArrowRight\") {\n        setDirection((cur) => (cur === \"left\" ? \"left\" : \"right\"));\n      } else if (e.key === \"ArrowLeft\") {\n        setDirection((cur) => (cur === \"right\" ? \"right\" : \"left\"));\n      } else if (e.key === \"ArrowUp\") {\n        setDirection((cur) => (cur === \"down\" ? \"down\" : \"up\"));\n      } else if (e.key === \"ArrowDown\") {\n        setDirection((cur) => (cur === \"up\" ? \"up\" : \"down\"));\n      }\n    };\n  }, []);\n\n  const move = () => {\n    if (gameOver) {\n      return;\n    }\n    const [curRow, curCol] = snake[snake.length - 1].split(\":\");\n    let nextRow = Number(curRow);\n    let nextCol = Number(curCol);\n    if (direction === \"up\") {\n      nextRow--;\n    } else if (direction === \"down\") {\n      nextRow++;\n    } else if (direction === \"right\") {\n      nextCol++;\n    } else if (direction === \"left\") {\n      nextCol--;\n    }\n\n    if (nextRow < 0 || nextRow >= rows || nextCol < 0 || nextCol >= columns) {\n      setGameOver(true);\n      return;\n    }\n\n    const nextHead = `${nextRow}:${nextCol}`;\n\n    if (nextHead === foodCell) {\n      setSnake([...snake, nextHead]);\n      let randomPosition = null;\n\n      while (!randomPosition) {\n        const col = getRandomInt(columns);\n        const row = getRandomInt(rows);\n        if (!snakeCells[`${row}:${col}`]) {\n          randomPosition = `${row}:${col}`;\n        }\n      }\n\n      setFoodCell(randomPosition);\n    } else if (snakeCells[nextHead]) {\n      setGameOver(true);\n    } else {\n      setSnake([...snake.slice(1), nextHead]);\n    }\n  };\n\n  useEffect(move, [tick]);\n\n  useEffect(() => {\n    const newSnakeCells: any = {};\n    snake.forEach((node) => {\n      newSnakeCells[node] = true;\n    });\n    setSnakeCells(newSnakeCells);\n    if (snake.length > bestScore) {\n      setBestScore(snake.length);\n    }\n  }, [snake]);\n\n  for (let i = 0; i < rows; i++) {\n    const row = [];\n    for (let j = 0; j < columns; j++) {\n      let type: CellType = \"empty\";\n      const key = `${i}:${j}`;\n      if (snakeCells[key]) {\n        if (gameOver) {\n          type = \"dead-snake\";\n        } else {\n          type = \"snake\";\n        }\n      } else if (key === foodCell) {\n        type = \"food\";\n      }\n      if (type === \"food\") {\n        row.push(\n          <Cell type={\"empty\"} key={key}>\n            <Cell type={\"food\"} key={key} />\n          </Cell>\n        );\n      } else {\n        row.push(<Cell type={type} key={key} />);\n      }\n    }\n    matrix.push(\n      <div className=\"row\" key={i}>\n        {row}\n      </div>\n    );\n  }\n  return (\n    <section className=\"page\">\n      <span className=\"score\">Current score: {snake.length}</span>\n      <span className=\"score\">Best score: {bestScore}</span>\n      <div className=\"field\">{matrix}</div>\n    </section>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './components/app/App';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}